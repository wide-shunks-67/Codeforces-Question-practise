#include<iostream>#include<vector>#include<algorithm>using namespace std;void solve(){    long long n;    cin>>n;        if(n==0){        cout<<0<<endl;        return;    }     vector<long long> odd,even;    for(long long i=0;i<n;i++){        long long val;        cin>>val;        if(val%2!=0){            odd.push_back(val);        }        else {            even.push_back(val);        }    }     sort(odd.rbegin(),odd.rend());    sort(even.rbegin(),even.rend());     int count_odd= odd.size();    int count_even= even.size();     //compute prefix sum of even     vector<long long> prefix_sum_of_even(count_even + 1,0);    for(int i=0;i< count_even;i++){        prefix_sum_of_even[i+1]=prefix_sum_of_even[i]+even[i];    }     for(int k=1;k<=n;k++){        if(count_odd==0){            cout<<0<<" ";            continue;        }         long long max_odd=odd[0];        int operations_remaining= k-1;        int take_evens= min(operations_remaining,count_even);         int extra_odds_need_to_be_taken= operations_remaining - take_evens;         // we need an even number of extra odd to ensure they cancel out        if(extra_odds_need_to_be_taken%2!=0){            //if extra odd count is odd we must sawp one even with one odd            //this decreases take_even count by 1 and increase extra odd count by 1             take_evens--;            extra_odds_need_to_be_taken++;        }        // we check for validation as take_evens can be         if(take_evens<0 || (1 + extra_odds_need_to_be_taken)>count_odd ){            cout<<0<<" ";        }        else{            cout<<(max_odd + prefix_sum_of_even[take_evens])<<" ";        }    }    cout<<endl;}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    int t;    cin>>t;    while(t--){        solve();    }    return 0;}